# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.22.0
# source: letter.sql
import dataclasses
import datetime
import decimal
from typing import AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.generated import models


CREATE_LETTER = """-- name: create_letter \\:one
INSERT INTO letter (
    buyer_name,
    buyer_email,
    buyer_address_line_1,
    buyer_address_line_2,
    buyer_postal_code,
    buyer_city,
    buyer_country,
    seller_name,
    seller_address_line_1,
    seller_address_line_2,
    seller_postal_code,
    seller_city,
    seller_country,
    purchase_date,
    product_name,
    order_reference,
    product_price,
    defect_type,
    defect_description,
    used,
    digital
) VALUES (
    :p1\\:\\:text,
    :p2\\:\\:text,
    :p3\\:\\:text,
    :p4\\:\\:text,
    :p5\\:\\:text,
    :p6\\:\\:text,
    :p7\\:\\:text,
    :p8\\:\\:text,
    :p9\\:\\:text,
    :p10\\:\\:text,
    :p11\\:\\:text,
    :p12\\:\\:text,
    :p13\\:\\:text,
    :p14\\:\\:date,
    :p15\\:\\:text,
    :p16\\:\\:text,
    :p17\\:\\:numeric,
    :p18\\:\\:defect_type_enum,
    :p19\\:\\:text,
    :p20\\:\\:boolean,
    :p21\\:\\:boolean
)
RETURNING id, buyer_name, buyer_email, buyer_address_line_1, buyer_address_line_2, buyer_postal_code, buyer_city, buyer_country, seller_name, seller_email, seller_address_line_1, seller_address_line_2, seller_postal_code, seller_city, seller_country, purchase_date, product_name, product_price, order_reference, used, digital, defect_type, defect_description, content, status, created_at, updated_at
"""


@dataclasses.dataclass()
class CreateLetterParams:
    buyer_name: str
    buyer_email: Optional[str]
    buyer_address_line_1: str
    buyer_address_line_2: Optional[str]
    buyer_postal_code: str
    buyer_city: str
    buyer_country: str
    seller_name: str
    seller_address_line_1: str
    seller_address_line_2: Optional[str]
    seller_postal_code: str
    seller_city: str
    seller_country: str
    purchase_date: datetime.date
    product_name: str
    order_reference: Optional[str]
    product_price: decimal.Decimal
    defect_type: models.DefectTypeEnum
    defect_description: str
    used: bool
    digital: bool


DELETE_LETTER = """-- name: delete_letter \\:exec
DELETE FROM letter
WHERE id = :p1\\:\\:uuid
"""


GET_LETTER_BY_ID = """-- name: get_letter_by_id \\:one
SELECT id, buyer_name, buyer_email, buyer_address_line_1, buyer_address_line_2, buyer_postal_code, buyer_city, buyer_country, seller_name, seller_email, seller_address_line_1, seller_address_line_2, seller_postal_code, seller_city, seller_country, purchase_date, product_name, product_price, order_reference, used, digital, defect_type, defect_description, content, status, created_at, updated_at
FROM letter
WHERE id = :p1\\:\\:uuid
LIMIT 1
"""


LIST_LETTERS = """-- name: list_letters \\:many
SELECT id, buyer_name, buyer_email, buyer_address_line_1, buyer_address_line_2, buyer_postal_code, buyer_city, buyer_country, seller_name, seller_email, seller_address_line_1, seller_address_line_2, seller_postal_code, seller_city, seller_country, purchase_date, product_name, product_price, order_reference, used, digital, defect_type, defect_description, content, status, created_at, updated_at
FROM letter
ORDER BY created_at DESC
LIMIT :p2\\:\\:int OFFSET :p1\\:\\:int
"""


UPDATE_CONTENT = """-- name: update_content \\:one
UPDATE letter
SET
    content = :p1\\:\\:text,
    status = :p2\\:\\:letter_status_enum,
    updated_at = now()
WHERE id = :p3\\:\\:uuid
RETURNING id, buyer_name, buyer_email, buyer_address_line_1, buyer_address_line_2, buyer_postal_code, buyer_city, buyer_country, seller_name, seller_email, seller_address_line_1, seller_address_line_2, seller_postal_code, seller_city, seller_country, purchase_date, product_name, product_price, order_reference, used, digital, defect_type, defect_description, content, status, created_at, updated_at
"""


UPDATE_LETTER_STATUS = """-- name: update_letter_status \\:one
UPDATE letter
SET
    status = :p1\\:\\:letter_status_enum,
    updated_at = now()
WHERE id = :p2\\:\\:uuid
RETURNING id, buyer_name, buyer_email, buyer_address_line_1, buyer_address_line_2, buyer_postal_code, buyer_city, buyer_country, seller_name, seller_email, seller_address_line_1, seller_address_line_2, seller_postal_code, seller_city, seller_country, purchase_date, product_name, product_price, order_reference, used, digital, defect_type, defect_description, content, status, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_letter(self, arg: CreateLetterParams) -> Optional[models.Letter]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_LETTER), {
            "p1": arg.buyer_name,
            "p2": arg.buyer_email,
            "p3": arg.buyer_address_line_1,
            "p4": arg.buyer_address_line_2,
            "p5": arg.buyer_postal_code,
            "p6": arg.buyer_city,
            "p7": arg.buyer_country,
            "p8": arg.seller_name,
            "p9": arg.seller_address_line_1,
            "p10": arg.seller_address_line_2,
            "p11": arg.seller_postal_code,
            "p12": arg.seller_city,
            "p13": arg.seller_country,
            "p14": arg.purchase_date,
            "p15": arg.product_name,
            "p16": arg.order_reference,
            "p17": arg.product_price,
            "p18": arg.defect_type,
            "p19": arg.defect_description,
            "p20": arg.used,
            "p21": arg.digital,
        })).first()
        if row is None:
            return None
        return models.Letter(
            id=row[0],
            buyer_name=row[1],
            buyer_email=row[2],
            buyer_address_line_1=row[3],
            buyer_address_line_2=row[4],
            buyer_postal_code=row[5],
            buyer_city=row[6],
            buyer_country=row[7],
            seller_name=row[8],
            seller_email=row[9],
            seller_address_line_1=row[10],
            seller_address_line_2=row[11],
            seller_postal_code=row[12],
            seller_city=row[13],
            seller_country=row[14],
            purchase_date=row[15],
            product_name=row[16],
            product_price=row[17],
            order_reference=row[18],
            used=row[19],
            digital=row[20],
            defect_type=row[21],
            defect_description=row[22],
            content=row[23],
            status=row[24],
            created_at=row[25],
            updated_at=row[26],
        )

    async def delete_letter(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_LETTER), {"p1": id})

    async def get_letter_by_id(self, *, id: uuid.UUID) -> Optional[models.Letter]:
        row = (await self._conn.execute(sqlalchemy.text(GET_LETTER_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.Letter(
            id=row[0],
            buyer_name=row[1],
            buyer_email=row[2],
            buyer_address_line_1=row[3],
            buyer_address_line_2=row[4],
            buyer_postal_code=row[5],
            buyer_city=row[6],
            buyer_country=row[7],
            seller_name=row[8],
            seller_email=row[9],
            seller_address_line_1=row[10],
            seller_address_line_2=row[11],
            seller_postal_code=row[12],
            seller_city=row[13],
            seller_country=row[14],
            purchase_date=row[15],
            product_name=row[16],
            product_price=row[17],
            order_reference=row[18],
            used=row[19],
            digital=row[20],
            defect_type=row[21],
            defect_description=row[22],
            content=row[23],
            status=row[24],
            created_at=row[25],
            updated_at=row[26],
        )

    async def list_letters(self, *, page_offset: int, page_size: int) -> AsyncIterator[models.Letter]:
        result = await self._conn.stream(sqlalchemy.text(LIST_LETTERS), {"p1": page_offset, "p2": page_size})
        async for row in result:
            yield models.Letter(
                id=row[0],
                buyer_name=row[1],
                buyer_email=row[2],
                buyer_address_line_1=row[3],
                buyer_address_line_2=row[4],
                buyer_postal_code=row[5],
                buyer_city=row[6],
                buyer_country=row[7],
                seller_name=row[8],
                seller_email=row[9],
                seller_address_line_1=row[10],
                seller_address_line_2=row[11],
                seller_postal_code=row[12],
                seller_city=row[13],
                seller_country=row[14],
                purchase_date=row[15],
                product_name=row[16],
                product_price=row[17],
                order_reference=row[18],
                used=row[19],
                digital=row[20],
                defect_type=row[21],
                defect_description=row[22],
                content=row[23],
                status=row[24],
                created_at=row[25],
                updated_at=row[26],
            )

    async def update_content(self, *, content: Optional[str], status: models.LetterStatusEnum, id: uuid.UUID) -> Optional[models.Letter]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_CONTENT), {"p1": content, "p2": status, "p3": id})).first()
        if row is None:
            return None
        return models.Letter(
            id=row[0],
            buyer_name=row[1],
            buyer_email=row[2],
            buyer_address_line_1=row[3],
            buyer_address_line_2=row[4],
            buyer_postal_code=row[5],
            buyer_city=row[6],
            buyer_country=row[7],
            seller_name=row[8],
            seller_email=row[9],
            seller_address_line_1=row[10],
            seller_address_line_2=row[11],
            seller_postal_code=row[12],
            seller_city=row[13],
            seller_country=row[14],
            purchase_date=row[15],
            product_name=row[16],
            product_price=row[17],
            order_reference=row[18],
            used=row[19],
            digital=row[20],
            defect_type=row[21],
            defect_description=row[22],
            content=row[23],
            status=row[24],
            created_at=row[25],
            updated_at=row[26],
        )

    async def update_letter_status(self, *, status: models.LetterStatusEnum, id: uuid.UUID) -> Optional[models.Letter]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_LETTER_STATUS), {"p1": status, "p2": id})).first()
        if row is None:
            return None
        return models.Letter(
            id=row[0],
            buyer_name=row[1],
            buyer_email=row[2],
            buyer_address_line_1=row[3],
            buyer_address_line_2=row[4],
            buyer_postal_code=row[5],
            buyer_city=row[6],
            buyer_country=row[7],
            seller_name=row[8],
            seller_email=row[9],
            seller_address_line_1=row[10],
            seller_address_line_2=row[11],
            seller_postal_code=row[12],
            seller_city=row[13],
            seller_country=row[14],
            purchase_date=row[15],
            product_name=row[16],
            product_price=row[17],
            order_reference=row[18],
            used=row[19],
            digital=row[20],
            defect_type=row[21],
            defect_description=row[22],
            content=row[23],
            status=row[24],
            created_at=row[25],
            updated_at=row[26],
        )
